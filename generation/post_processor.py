"""
Response Post-Processor

This module handles post-processing of generated responses,
including formatting, cleaning, and enhancement.
"""

import re
from typing import Dict, Any, List, Optional
import structlog

logger = structlog.get_logger(__name__)


class PostProcessor:
    """
    Post-processor for generated responses.
    
    This class handles cleaning, formatting, and enhancing
    responses generated by the LLM.
    """
    
    def __init__(self):
        """Initialize the post-processor."""
        logger.info("Initializing response post-processor")
        self._setup_cleaners()
    
    def _setup_cleaners(self):
        """Setup text cleaning patterns."""
        self.cleaners = [
            # Remove excessive whitespace
            (r'\s+', ' '),
            # Remove leading/trailing whitespace
            (r'^\s+|\s+$', ''),
            # Fix common punctuation issues
            (r'\s+([.,!?])', r'\1'),
            # Remove empty lines
            (r'\n\s*\n', '\n'),
        ]
    
    def process(self, response: str, **kwargs: Any) -> Dict[str, Any]:
        """
        Process a generated response.
        
        Args:
            response: The raw generated response
            **kwargs: Additional processing parameters
            
        Returns:
            Dictionary containing processed response and metadata
        """
        try:
            logger.info(f"Processing response with {len(response)} characters")
            
            # Clean the response
            cleaned_response = self._clean_response(response)
            
            # Extract metadata
            metadata = self._extract_metadata(cleaned_response)
            
            # Enhance the response
            enhanced_response = self._enhance_response(cleaned_response, metadata)
            
            # Calculate confidence
            confidence = self._calculate_confidence(enhanced_response, metadata)
            
            result = {
                "response": enhanced_response,
                "original_length": len(response),
                "processed_length": len(enhanced_response),
                "confidence": confidence,
                "metadata": metadata,
                "processing_info": {
                    "cleaned": True,
                    "enhanced": True,
                    "confidence_calculated": True
                }
            }
            
            logger.info(f"Response processed successfully. Confidence: {confidence:.2f}")
            return result
            
        except Exception as e:
            logger.error(f"Error processing response: {e}")
            return {
                "response": response,
                "error": str(e),
                "confidence": 0.0
            }
    
    def _clean_response(self, response: str) -> str:
        """
        Clean the response text.
        
        Args:
            response: Raw response text
            
        Returns:
            Cleaned response text
        """
        cleaned = response
        
        # Apply cleaning patterns
        for pattern, replacement in self.cleaners:
            cleaned = re.sub(pattern, replacement, cleaned)
        
        # Remove any remaining artifacts
        cleaned = cleaned.strip()
        
        logger.debug(f"Cleaned response from {len(response)} to {len(cleaned)} characters")
        return cleaned
    
    def _extract_metadata(self, response: str) -> Dict[str, Any]:
        """
        Extract metadata from the response.
        
        Args:
            response: The response text
            
        Returns:
            Dictionary of metadata
        """
        metadata = {
            "word_count": len(response.split()),
            "sentence_count": len(re.split(r'[.!?]+', response)),
            "has_questions": '?' in response,
            "has_numbers": bool(re.search(r'\d', response)),
            "has_urls": bool(re.search(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response)),
            "tone": self._detect_tone(response),
            "complexity": self._calculate_complexity(response)
        }
        
        return metadata
    
    def _detect_tone(self, response: str) -> str:
        """
        Detect the tone of the response.
        
        Args:
            response: The response text
            
        Returns:
            Detected tone (formal, friendly, technical, etc.)
        """
        response_lower = response.lower()
        
        # Simple tone detection based on keywords
        if any(word in response_lower for word in ['please', 'thank you', 'kindly']):
            return "polite"
        elif any(word in response_lower for word in ['technical', 'specification', 'parameter']):
            return "technical"
        elif any(word in response_lower for word in ['hello', 'hi', 'welcome']):
            return "friendly"
        elif any(word in response_lower for word in ['therefore', 'consequently', 'thus']):
            return "formal"
        else:
            return "neutral"
    
    def _calculate_complexity(self, response: str) -> float:
        """
        Calculate the complexity score of the response.
        
        Args:
            response: The response text
            
        Returns:
            Complexity score (0.0 to 1.0)
        """
        words = response.split()
        if not words:
            return 0.0
        
        # Calculate average word length
        avg_word_length = sum(len(word) for word in words) / len(words)
        
        # Calculate sentence complexity
        sentences = re.split(r'[.!?]+', response)
        avg_sentence_length = sum(len(s.split()) for s in sentences if s.strip()) / max(len(sentences), 1)
        
        # Normalize complexity score
        complexity = (avg_word_length / 10.0 + avg_sentence_length / 20.0) / 2.0
        return min(complexity, 1.0)
    
    def _enhance_response(self, response: str, metadata: Dict[str, Any]) -> str:
        """
        Enhance the response based on metadata.
        
        Args:
            response: The cleaned response
            metadata: Response metadata
            
        Returns:
            Enhanced response
        """
        enhanced = response
        
        # Add formatting based on tone
        if metadata["tone"] == "technical" and not enhanced.startswith("#"):
            enhanced = f"## Technical Response\n\n{enhanced}"
        elif metadata["tone"] == "friendly" and not enhanced.startswith("Hi"):
            enhanced = f"Hi there! {enhanced}"
        
        # Add confidence indicator if confidence is low
        if metadata.get("confidence", 1.0) < 0.5:
            enhanced += "\n\n*Note: This response is based on available information and may need verification.*"
        
        return enhanced
    
    def _calculate_confidence(self, response: str, metadata: Dict[str, Any]) -> float:
        """
        Calculate confidence score for the response.
        
        Args:
            response: The processed response
            metadata: Response metadata
            
        Returns:
            Confidence score (0.0 to 1.0)
        """
        # Base confidence
        confidence = 0.7
        
        # Adjust based on response length
        if len(response) > 50:
            confidence += 0.1
        
        # Adjust based on complexity
        if metadata["complexity"] > 0.5:
            confidence += 0.1
        
        # Adjust based on tone
        if metadata["tone"] in ["formal", "technical"]:
            confidence += 0.05
        
        # Penalize for questions (indicates uncertainty)
        if metadata["has_questions"]:
            confidence -= 0.1
        
        return min(max(confidence, 0.0), 1.0)
    
    def format_for_display(self, processed_response: Dict[str, Any]) -> str:
        """
        Format the processed response for display.
        
        Args:
            processed_response: The processed response dictionary
            
        Returns:
            Formatted string for display
        """
        response = processed_response["response"]
        confidence = processed_response.get("confidence", 0.0)
        metadata = processed_response.get("metadata", {})
        
        # Create display format
        display = f"{response}\n\n"
        display += f"---\n"
        display += f"Confidence: {confidence:.1%}\n"
        display += f"Word count: {metadata.get('word_count', 0)}\n"
        display += f"Tone: {metadata.get('tone', 'unknown')}\n"
        
        return display 